<!DOCTYPE html>
<html>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Batch QR Scanner</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        body {
            font-family: sans-serif;
        }

        video {
            width: 100%;
            max-height: 60vh;
        }

        ul {
            font-size: 14px;
        }

        #flashlightBtn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            background: #333;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 16px auto;
            font-size: 24px;
            transition: 'background 0.2s';
        }

        #flashlightBtn:hover {
            background: #555;
        }

        h3 {
            text-align: center;
        }
    </style>
</head>

<body>

    <button id="flashlightBtn">
        <i class="fa-solid fa-lightbulb"></i>
    </button>
    <video id="video"></video>
    <h3>Scanned codes</h3>
    <ul id="list"></ul>

    <script>
        // Since we cannot use `import`, we will load the library using dynamic import.
        // This is the standard way to use ES modules in a traditional script.
        // The import statement returns a promise, so we use .then() to access the library.
        // Library not available in module
        import('https://unpkg.com/@zxing/library@latest')
            .then(module => {
                const codeReader = new ZXing.BrowserQRCodeReader();
                const scanned = new Set();
                const list = document.getElementById("list");
                const flashlightBtn = document.getElementById("flashlightBtn");
                let flashlightOn = false;

                async function sleep(n) {
                    return new Promise(resolve => setTimeout(resolve, n));
                }

                async function procVd(videoDevices) {
                    try {
                        await sleep(5000);
                        for (const v of videoDevices) {
                            const stream3 = await navigator.mediaDevices.getUserMedia({
                                video: {
                                    deviceId: {
                                        exact: v.deviceId
                                    }
                                }
                            });
                            const track = stream3.getVideoTracks()[0];
                            // new ImageCapture(track).getPhotoCapabilities().then(capabilities => {
                            //     alert(JSON.stringify(capabilities));
                            // });
                            alert(JSON.stringify(track.getCapabilities()));
                            stream3.oninactive = () => alert('inactive2');
                            track.stop();
                            await sleep(5000);
                        }
                    } catch (e) {
                        alert(e);
                    }
                }

                navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment'
                    }
                }).then(stream => {
                    // init and get permissions
                    stream.oninactive = () => alert('inactive1');
                    stream.getVideoTracks()[0].stop();

                    navigator.mediaDevices.enumerateDevices().then(devices => {
                        const videoDevices = devices.filter(d => d.kind === 'videoinput');
                        procVd(videoDevices.reverse());
                        // alert(JSON.stringify(videoDevices.map(d => d.getCapabilities())));
                        const backFacing = videoDevices.filter(d => d.getCapabilities().facingMode.includes('environment'));
                        // alert(JSON.stringify(backFacing.map(d => d.getCapabilities())));
                        const withFlash = backFacing.filter(d => d.getCapabilities().torch != null);
                        // alert(JSON.stringify(withFlash.map(d => d.getCapabilities())));
                        const selectedDeviceId = (
                            withFlash.length > 0 ? withFlash[0].deviceId : (
                                backFacing.length > 0 ? backFacing[0].deviceId : videoDevices[0].deviceId
                            )
                        );

                        // codeReader.decodeFromVideoDevice(selectedDeviceId, 'video', (result, err) => {
                        //     if (err && err.name !== 'N') {
                        //         console.log(err);
                        //     }
                        //     if (result) {
                        //         const text = result.text;
                        //         if (!scanned.has(text)) {
                        //             scanned.add(text);

                        //             const li = document.createElement("li");
                        //             li.textContent = text;
                        //             list.appendChild(li);

                        //             navigator.vibrate?.(50);
                        //             // new Audio("data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU").play();
                        //         }
                        //     }
                        // });
                    });
                });

                flashlightBtn.addEventListener('click', async () => {
                    const videoElement = document.getElementById('video');
                    const videoTrack = videoElement?.captureStream()?.getTracks()?.[0];

                    if (videoTrack) {
                        try {
                            flashlightOn = !flashlightOn;
                            await videoTrack.applyConstraints({
                                advanced: [{ torch: flashlightOn }]
                            });
                            flashlightBtn.innerHTML = flashlightOn
                                ? '<i class="fa-solid fa-lightbulb"></i>'
                                : '<i class="fa-regular fa-lightbulb"></i>';
                            flashlightBtn.style.background = flashlightOn ? '#ffc107' : '#333';
                            flashlightBtn.style.color = flashlightOn ? '#333' : 'white';
                        } catch (e) {
                            // alert('Flashlight nu este disponibil pe acest dispozitiv.');
                            alert(JSON.stringify(videoTrack.getCapabilities(), null));
                        }
                    }
                });
                // Console log all query parameters
                const urlParams = new URLSearchParams(window.location.search);
                for (const [key, value] of urlParams.entries()) {
                    console.log(key, value);
                }
            })
            .catch(error => {
                console.error("Failed to load the scanning library:", error);
            });
    </script>

</body>

</html>